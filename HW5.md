# Уроки 4-5 - полиморфизм, наследование, декораторы и итераторы
## Контрольные вопросы:
- В чем основная идея __полиморфизма__? Как он реализуется в Python.

*Основная идея - создание единого интерфейса для множественной реализации объектами разных классов. В python полиморфизм достигается с помощью наследования и динамической типизации(тип переменной определяется во время выполнения)*

- Зачем переопределять метод `__radd__()` наравне с 
`__add__()`?

*Это необходимо в случаях, когда левый операнд не имеет метода __add__(), или когда его метод __add__() не знает, как обработать правый операнд.*

- Как можно описать взаимоотношения 
__родительского__ и __дочернего__ классов?

*Они характеризуются наследованием. То есть от родительского класса (в целом от предков) передаются методы дочернему классу. С точки зрения кода - потомок расширяет предков, а по логике - потомок уточняет предка. Потомок способен переопределять родительские методы*

- Для чего используется ключевое 
слово `super()`?

*Потомок способен дополнять унаследованные методы через `super()`. Происходит подстановка класса предка по порядку разрешения методов C3 MRO*

- Какую роль играет порядок классов __предков__
при __множественном наследовании__?

*Порядок классов предков важен при разрешении конфликтов в потомках. Если несколько классов-предков имеют метод с одним именем, то метод, найденный раньше в MRO и будет использоваться.*

- Зачем нужна __обработка исключений__? В каких 
случаях ее использование некорректно?

*Обработка исключений необходима для того, чтобы программа не завершалась аварийно каждый раз при возникновении исключения, вместо этого будет выполнятся другая команда (прописывается в except). Использование обработки исключений может быть некорректным, если есть иной вариант перехвата ошибки - например попросить пользователя ввести корректное значение, вместо неправильного.*

- Зачем в блоке `try` использовать раздел
`finally`?

*Этот раздел обеспечивает обязательное выполнение некоторых действий в любом случае. Например, это полезно когда программа работает с файлами, и при остановке этот файл всё-равно надо закрыть.*

- Что нужно сделать, чтобы реализовать 
свое собственное __исключение__?

*Нужно создать новый класс, который наследуется от базового класса исключений.*

- Чем итератор отличается от генератора?

*Генераторы создаются с помощью ключевого слова yield, а итераторы могут быть созданы с помощью класса, реализующего методы __iter__() и __next__(). Каждый генератор является итератором, но не наоборот.*

- В чем минусы декорирования функций?

*Частичная потеря информации, например передаём функцию, а вот её аргумент автоматически не передаётся.*

## Задания:
1) Доработайте класс комплексного числа из прошлого 
занятия: переопределите математические 
операторы (__+, -, /, *, ==__), так, чтобы они
работали с другими комплексными и со стандартными
числами. Добейтесь правильной работы с комплексным 
числом функций `print()`, `abs()`, а также
реализуйте `getter` и `setter` 
с использованием декоратора `@property`. Добавьте 
выбросы исключений при некорректном использовании 
вашего числа, например: выбросом `ValueError` при вводе 
некорректных значений в `setter` класса, выбросом своего исключения в 
случае попытки перевода в экспоненциальную 
форму, когда это невозможно. Поверх напишите программу 
калькулятор, принимающую у пользователя два комплексных
числа и проводящую с ними арифметические операции на
выбор пользователя. Калькулятор должен уметь ловить и 
обрабатывать исключения, не роняя программу,
а объясняя пользователю, что пошло не так.
2) Реализуйте класс связного списка `LinkedList`. 
(Вам потребуется реализовать вспомогательный класс `Node`,
содержащий в себе ссылки на соседей, и свое значение. Тогда
сам список содержит в себе лишь ссылку на первую вершину,
и вспомогательные данные вроде текущей длины). Список 
должен поддерживать обращение по индексам, красиво печататься,
выдавать длину через `len()` и иметь работающие методы
`.pop()`, `.append()`. Также список должен поддерживать
итерацию по нему. *Можете также добавить `.insert()` и 
`.pop()` по индексу.
3) Реализовать структуру наследования классов 
геометрических фигур *shape*. Каждый 
класс должен обладать методами `.area()`_ и 
`.perimeter()` для вычисления площади и 
периметра соответственно, а также метод `__str__()`. Среди обязательных для 
реализации структур: круг, треугольник, 
прямоугольник, квадрат, ромб. Для простоты часть фигур
можно конструировать из точек, 
передающихся в порядке обхода фигуры по 
часовой стрелке.